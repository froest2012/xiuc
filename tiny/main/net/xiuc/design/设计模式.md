###大话设计模式
####1. 简单工厂模式
####2. 策略模式
	策略模式其实是面向接口编程的一种方式，其步骤可以简单归纳为：
	1. 定义一个接口
	2. 对这个接口做不同的实现
	3. 提供一个上下文，用于提供给调用方根据场景实例化相应的实现类
	
	public interface Favorable{
		Integer calculateFavorable(Integer a, Integer b);
	}
	
	public class FavorableA implements Favorable {
		@Override
		Integer calculateFavorable(Integer a, Integer b){
			return a + b;
		}
	}
	
	public class FavorableB implements Favorable {
		@Override
		Integer calculateFavorable(Integer a, Integer b){
			return (a + b) * 0.95;
		}
	}
	
	public class FavorableC implements Favorable {
		@Override
		Integer calculateFavorable(Integer a, Integer b){
			return (a + b) * 0.9;
		}
	}
	//供客户端调用
	public class FavorableContext {
		private Favorable favorable;
		public FavorableContext(Favorable favorable){
			this.favorable = favorable;
		}
		Integer getResult(Integer a, Integer b){
			return favorable.calculateFavorable(a,b)
		}
	}
####3. 单一职责原则
	就一个类而言，应该仅有一个引起他变化的原因
####4. 开放-封闭原则
	对于扩展开放，对于更改封闭，这样既可以做到适应新需求，又不会影响原有代码
####5. 依赖倒转原则
	高层模块不应该依赖低层模块，两者都应该依赖接口或者抽象
	抽象不应该依赖细节，细节应该依赖抽象
####6. 里氏代换原则
	子类型必须能够替换父类型
####7. 装饰者模式
	装饰者模式用于动态的为已有功能添加新功能的一种方式，装饰者模式可以把类中的装饰职责从类中移除出去。装饰者模式可以有效的把类的核心功能和装饰功能区分开来，而且可以有效的去除相关类中重复的装饰逻辑
	用途：可以用来设计流程引擎，每一个流程都可以通过配置灵活的添加，可以按照顺序执行每一个流程
	
	/**
	* 装饰者模式抽象类
	* Created by 秀川 on 16/3/10.
	*/
	public abstract class Component {
    	public abstract void operate();
	}
	
	/**
 	* 被添加动态信息的类
	*/
	public class ConcreteComponent extends Component {
	
    	@Override
    	public void operate() {
	        System.out.println("ConcreteComponent");
    	}
	}
	
	/**
	 * 装饰器
	 */
	public class Decorator extends Component {
    	private Component component;
	
    	public void setComponent(Component component){
        	this.component = component;
	    }
	
    	@Override
	    public void operate() {
    	    if(component != null){
        	    component.operate();
        	}
	    }
	}

	/**
 	* 装饰器的一种实现,用于添加信息
 	* Created by 秀川 on 16/3/10.
 	*/
	public class ConcreteComponentA extends Decorator {
	
    	private String state;
	
    	@Override
	    public void operate() {
    	    super.operate();
        	state = "添加的状态";
	        System.out.println(state);
    	}
	}
	
	/**
 	* 装饰器的一种实现,用于添加信息
 	* Created by 秀川 on 16/3/10.
 	*/
	public class ConcreteComponentB extends Decorator{
	
    	@Override
	    public void operate(){
    	    super.operate();
        	print();
	    }
	
    	private void print(){
        	System.out.println("这是后面添加的方法");
    	}
	
	}

	public class MainTest {

    	public static void main(String[] args) {
        	ConcreteComponent concreteComponent = new ConcreteComponent();
	        ConcreteComponentA concreteComponentA = new ConcreteComponentA();
    	    ConcreteComponentB concreteComponentB = new ConcreteComponentB();
	
    	    concreteComponentA.setComponent(concreteComponent);
        	concreteComponentB.setComponent(concreteComponentA);
	
    	    concreteComponentB.operate();
	    }
	}
	
	结果输出为：
	ConcreteComponent
	添加的状态
	这是后面添加的方法
	
####8. 代理模式
	代理模式为其他对象提供一种代理以控制对这个对象的访问
	代理的应用场景：
	1. 远程代理，为一个对象在不同的地址空间提供局部代理，这样可以隐藏一个对象存在于不同地址空间的实时
	2. 虚拟代理，根据需要创建开销很大的对象，通过他来实现实例化需要很长时间的真实对象（网页上图片显示优化）
	3. 安全代理，用于控制真实对象访问时的权限（对真实对象的包装，只能使用提供的方法）
	4. 只能指引，指调用真实对象的时候，处理一些其他的事情（比如面向切面编程就需要使用到代理）
	代理和真实对象都实现同一个接口，这样代理便可以代替真实对象处理所有的事情
	
	/**
	 * 代理与真实对象的共同接口
	 *
	 * Created by 秀川 on 16/3/12.
	 */
	public interface Subject {
    	void request();
	}
	
	/**
	 * 真实对象实现接口
	 *
	 * Created by 秀川 on 16/3/12.
	 */
	public class RealSubject implements Subject {
	    public void request() {
	        System.out.println("RealSubject发出请求");
	    }
	}
	
	/**
	 * 代理实现接口, 控制对真实对象的访问
	 *
	 * Created by 秀川 on 16/3/12.
	 */
	public class Proxy implements Subject{
	    private RealSubject realSubject;
	
	    public Proxy(RealSubject realSubject){
	        if(realSubject == null){
	            this.realSubject = new RealSubject();
	        }else {
	            this.realSubject = realSubject;
	        }
	    }
	
	    public void request() {
	        realSubject.request();
	    }
	}

	/**
	 * 测试代理
	 *
	 * Created by 秀川 on 16/3/12.
	 */
	public class MainTest {
	
	    public static void main(String[] args){
	        Proxy proxy = new Proxy(new RealSubject());
	        proxy.request();
	    }
	}
#####9. 工厂方法模式
	工厂方法模式与简单工厂模式的区别就是工厂方法模式在简单工厂模式的基础下再进一步的抽象出创建工厂的接口，这个接口只有一个创建工厂的方法，所有的要生成具体类的工厂去实现这个方法，这样添加一种功能，我们只需要添加一个真实的功能类以及添加一个相应的工厂类即可，不需要像简单工厂模式一样改工厂类。
	/**
	 * 工厂方法接口
	 * Created by 秀川 on 16/3/13.
	 */
	public interface IFactory {
	    Leifeng creaeFactory();
	}
	
	/**
	 * 功能类接口
	 * Created by 秀川 on 16/3/13.
	 */
	public interface Leifeng {
	    void sweep();
	    void buyRice();
	    void wash();
	}
	
	/**
	 * 大学生类
	 * Created by 秀川 on 16/3/13.
	 */
	public class Undergraduate implements Leifeng {
	    public void sweep() {
	        System.out.println(Undergraduate.class + "扫地");
	    }
	
	    public void buyRice() {
	        System.out.println(Undergraduate.class + "买米");
	    }
	
	    public void wash() {
	        System.out.println(Undergraduate.class + "洗衣");
	    }
	}
	
	/**
	 * 社区志愿者类
	 * Created by 秀川 on 16/3/13.
	 */
	public class Volunteer implements Leifeng {
	    public void sweep() {
	        System.out.println(Volunteer.class + "扫地");
	    }
	
	    public void buyRice() {
	        System.out.println(Volunteer.class + "买米");
	    }
	
	    public void wash() {
	        System.out.println(Volunteer.class + "洗衣");
	    }
	}
	
	/**
	 * 大学生工厂类
	 * Created by 秀川 on 16/3/13.
	 */
	public class UnderGraduateFactory implements IFactory {
	    public Leifeng creaeFactory() {
	        return new Undergraduate();
	    }
	}
	
	/**
	 * 社区志愿者工厂类
	 * Created by 秀川 on 16/3/13.
	 */
	public class VolunteerFactory implements IFactory {
	    public Leifeng creaeFactory() {
	        return new Volunteer();
	    }
	}

	public class MainTest {
	    public static void main(String[] args) {
    	    Leifeng underGraduate = new UnderGraduateFactory().creaeFactory();
        	underGraduate.buyRice();
	        underGraduate.sweep();
    	    underGraduate.wash();
	        Leifeng volunteer = new VolunteerFactory().creaeFactory();
    	    volunteer.buyRice();
        	volunteer.sweep();
	        volunteer.wash();
    	}
	
	}

#####10. 原型模式
	原型模式就是从一个对象到再创建另一个可定制的对象，而且不需要知道任何创建细节，其实使用clone的方法复用原有对象的信息，要注意深拷贝和浅拷贝。
#####11. 模板方法模式
	定义一个算法的骨架，把某些实现的细节放到子类中，这样子类可以不用改变算法的结构就可以重新定义算法的某些步骤，模板方法一般是把子类的重复方法移动到父类中去，这样可以避免重复，如果一开始设计的时候就考虑用模板方法，需要考虑的比较全面
######12. 迪米特法则（最少知识原则）
	如果两个类不必彼此直接通信，那么这两个类不应该发生直接的相互作用，如果一个类被另一个类调用的话，可以通过第三个类转发这个调用
#####13. 外观模式
	为系统中的一组接口提供一致的界面，词模块定义类一个高层接口，这个接口使得这一子系统更加容易使用
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	